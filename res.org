
* 数字电路
** 数制及转换
*** 十进制(D)转成二进制(B)
    #+begin_example
      22.8125

      整数部分:
      22 = 2 * 11 + 0 ... 0
      11 = 2 * 5 + 1 .... 1
       5 = 2 * 2 + 1 .... 1
       2 = 2 * 1 + 0 .... 0
       1 = 2 * 0 + 1 .... 1

      从下往上:
      10110

      小数部分:
      0.8125 * 2 = 1.625 ... 1
       0.625 * 2 = 1.25 .... 1
        0.25 * 2 = 0.5 ..... 0
         0.5 * 2 = 1 ....... 1

      从上往下:
      1101

      结果:
      (22.8125)D = (10110.1101)B
    #+end_example

    1. 整数部分与 2 相除, 取出余数作为标识
    2. 与 2 相除的商作为下一个与 2 相除的被除数
    3. 重复 1-2, 直到商为 0
    4. 标识倒序排列即为整数部分
    5. 小数部分与 2 相乘, 结果大于 1 则取 1 作为标识, 否则取 0
    6. 结果的小数部分作为下一个与 2 相乘的项
    7. 重复 5-6, 直到结果没有小数部分为止
    8. 标识项正序排列即为小数部分
    9. 与整数部分合并

*** 将二进制(B)转成八进制(O)
    #+begin_example
      (110010.1101)D

      110 010 . 110 1

      110 010 . 110 100

      6 2 . 6 4

      (110010.1101)B = (62.64)O
    #+end_example

    1. 以小数点开始分割, 没三项一组, 不足补 0
    2. 把每组数转成十进制数
    3. 合并结果

*** 将八进制(O)转成二进制(B)
    #+begin_example
      (62.64)O

      62.64

      6 2 . 6 4
      110 010 . 110 100
      (62.64)O = (110010.110100)B
    #+end_example

    1. 以小数点开始分割每一个数
    2. 将每一个数转成 3 位二进制, 不够补 0
    3. 合并结果(删去无用 0)

*** 将二进制(B)转成十六进制(H)
    #+begin_example
      (1100001.1101)B

      110 0001 . 1101

      0110 0001 . 1101

      6  1  .  13

      6  1  .  D

      (1100001.1101)B = (61.D)H
    #+end_example

    1. 以小数点开始分割, 每 4 位为一组, 不足补 0
    2. 将每组数转成十进制数
    3. 将溢出的十进制转成十六进制
    4. 合并结果

*** 将十六进制(H)转成二进制(B)
    #+begin_example
      (61.D)H

      61.D

      6  1  .  D

      6  1  .  13

      0110  0001  .  1101

      (61.D)H = (1100001.1101)B
    #+end_example


    1. 以小数点开始分割每一个数
    2. 将每个数转成十进制
    3. 将每个数转成 4 位二进制, 不足补 0
    4. 合并结果

*** 要点
    1. 二进制: B, 八进制: O, 十进制: D, 十六进制: H 
    2. 二进制 互转 十进制, 二进制 互转 八进制, 二进制转换十六进制

       十进制转十六进制: 先转成二进制, 再转十六进制

       八进制转十进制: 先转成二进制, 再转十进制
** 逻辑门电路
*** 基本逻辑门
    [[./img/基本逻辑图.png]]

*** 函数表达式的逻辑门
    [[./img/函数表达式逻辑图.png]]
    
*** 给出函数表达式, 画逻辑图
    [[./img/逻辑门题1步骤1.png]]

    [[./img/逻辑门题1步骤2.png]]

** 化简逻辑表达式
*** 将卡诺图表示成逻辑表达式   
    [[./img/化简题1步骤1.png]]

    | AB\CD | 00 | 01 | 11 | 10 |
    |    00 |  1 |  0 |  1 |  1 |
    |    01 |  1 |  0 |  1 |  1 |
    |    11 |  0 |  1 |  1 |  1 |
    |    10 |  0 |  0 |  1 |  1 |

    
    ~L = C + A'D' + ABD~

    [[./img/化简题2步骤1.png]]

    | A\BC | 00 | 01 | 11 | 10 |
    |    0 |  0 |  0 |  1 |  0 |
    |    1 |  0 |  1 |  1 |  1 |

    ~L = AC + BC + AB~

*** 将逻辑表达式画进卡诺图
    #+begin_example
    L = AC = A'D' + CD' + A'C + ABD
    #+end_example

    | AB\CD | 00 | 01 | 11 | 10 |
    |    00 |  1 |  0 |  1 |  1 |
    |    01 |  1 |  0 |  1 |  1 |
    |    11 |  0 |  1 |  1 |  1 |
    |    10 |  0 |  0 |  1 |  1 |

    #+begin_example
    L = A'BC + AB'C + ABC' + ABC
    #+end_example

    | A\BC | 00 | 01 | 11 | 10 |
    |    0 |  0 |  0 |  1 |  0 |
    |    1 |  0 |  1 |  1 |  1 |

*** 用卡诺图化简逻辑表达式
    #+begin_example
      L = AC + A'D' + CD' + A'C + ABD
    #+end_example

    | AB\CD | 00 | 01 | 11 | 10 |
    |    00 |  1 |  0 |  1 |  1 |
    |    01 |  1 |  0 |  1 |  1 |
    |    11 |  0 |  1 |  1 |  1 |
    |    10 |  0 |  0 |  1 |  1 |

    ~L = C + ABD + A'D'~

    #+begin_example
    L = A'BC + AB'C + ABC' + ABC
    #+end_example

    | A\BC | 00 | 01 | 11 | 10 |
    |    0 |  0 |  0 |  1 |  0 |
    |    1 |  0 |  1 |  1 |  1 |

    ~L = AC + BC + AB~

*** 用公式法化简逻辑表达式

    [[./img/公式.png]]
    
    | 名称   | 公式 1                                   | 公式 2                    |
    | 0-1 律 | A * 1 = A                                | A + 0 = A                 |
    |        | A* 0 + 0                                 | A + 1 = 1                 |
    | 互补律 | AA' = 0                                  | A + A' = 1                |
    | 重叠律 | AA = A                                   | A + A = A                 |
    | 交换律 | AB = BA                                  | A + B = B + A             |
    | 结合律 | A(BC) = (AB)C                            | A + (B + C) = (A + B) + C |
    | 分配律 | (A + B)C = AC + BC                       | AB + C = (A + C)(B + C)   |
    | 反演律 | (AB)' = A' + B'                          | (A + B)' = A'B'           |
    | 吸收律 | A(A + B) = A                             | A + AB = A                |
    |        | A(A' + B) = AB                           | A + A'B = A + B           |
    |        | (A + B)(A' + C)(B + C) = (A + B)(A' + C) | AB + A'C + BC = AB + A'C  |
    | 对合律 | A'' = A                                  |                           |

    记忆技巧:
    #+begin_example
      公式1 <=> 公式2

      与 -> 或
      或 -> 与

      0 -> 1
      1 -> 0
    #+end_example

    #+begin_example
      L = A'BC + AB'C + ABC' + ABC
        = A'BC + AB'C + ABC' + ABC + ABC + ABC
        = (A'BC + ABC) + (AB'C + ABC) + (ABC' + ABC)
        = BC(A' + A) + AC(B' + B) + AB(C' + C)
        = BC + AC = AB
    #+end_example

*** 求公式表示函数的反函数
    1. 与 -> 或, 或 -> 与
    2. 0 -> 1, 1 -> 0
    3. 原变量 -> 反变量
    4. 反变量 -> 原变量
    5. 多个变量的公共非号保持不变
    6. 原式运算的优先顺序保持不变

       
    #+begin_example
      L = A + BC' + (ACD')'
        = A' * (B'+ C) * (A' + C' + D)'
    #+end_example

    

*** 求卡诺图表示函数的反函数
    | AB\CD | 00 | 01 | 11 | 10 |
    |    00 |  1 |  1 |  1 |  1 |
    |    01 |  0 |  1 |  1 |  1 |
    |    11 |  0 |  1 |  1 |  1 |
    |    10 |  1 |  1 |  1 |  1 |

    把 0 当 1, 1 当 0 看即反函数
    ~L' = BC'D'~

** 组合逻辑电路的分析与设计
*** 给出逻辑电路图, 分析逻辑功能
    1. 由逻辑图写出函数表达式
    2. 化简函数表达式
    3. 列出所有情况
    4. 分析出功能

       
    [[./img/逻辑电路图图1.png]]

    [[./img/逻辑电路图图1步骤2.png]]

    [[./img/逻辑电路图图1步骤3.png]]

    #+begin_example
      L = A(ABC)' + B(ABC)' + C(ABC)'
        = A(A' + B' + C') + B(A' + B' + C') + C(A' + B' + C')
        = AA' + AB' + AC' + A'B + BB' + BC' + A'C + B'C + CC'
        = AB' + AC' + A'B + BC' +  A'C + B'C

        由卡诺图得:
        = AB' + A'C + BC'
    #+end_example

    | A | B | C | L |
    | 0 | 0 | 0 | 0 |
    | 0 | 0 | 1 | 1 |
    | 0 | 1 | 0 | 1 |
    | 1 | 0 | 0 | 1 |
    | 0 | 1 | 1 | 1 |
    | 1 | 0 | 1 | 1 |
    | 1 | 1 | 0 | 1 |
    | 1 | 1 | 1 | 0 |

    由真值表可知, 当 A, B, C 不一致时, 电路输出为 "1", 所以, 这个电路为 "不一致
    电路"

*** 三种常考电路
    | A | B | C | L |
    | 0 | 0 | 0 | 0 |
    | 0 | 0 | 1 | 1 |
    | 0 | 1 | 0 | 1 |
    | 1 | 0 | 0 | 1 |
    | 0 | 1 | 1 | 1 |
    | 1 | 0 | 1 | 1 |
    | 1 | 1 | 0 | 1 |
    | 1 | 1 | 1 | 0 |

    不一致电路

    
    | A | B | C | L |
    | 0 | 0 | 0 | 1 |
    | 0 | 0 | 1 | 0 |
    | 0 | 1 | 0 | 0 |
    | 1 | 0 | 0 | 0 |
    | 0 | 1 | 1 | 0 |
    | 1 | 0 | 1 | 0 |
    | 1 | 1 | 0 | 0 |
    | 1 | 1 | 1 | 1 |

    一致电路

    | A | B | C | L |
    | 0 | 0 | 0 | 0 |
    | 0 | 0 | 1 | 0 |
    | 0 | 1 | 0 | 0 |
    | 1 | 0 | 0 | 0 |
    | 0 | 1 | 1 | 1 |
    | 1 | 0 | 1 | 1 |
    | 1 | 1 | 0 | 1 |
    | 1 | 1 | 1 | 1 |

    少数服从多数电路

    
*** 给出功能要求, 设计电路
    设计一个三人表决电路, 结果按 "少数服从多数" 原则决定

    1. 确定输入个数, 定义 0, 1
    2. 列真值表
    3. 写出逻辑表达式
    4. 化简
    5. 画出电路图

       
    | A | B | C | L |
    | 0 | 0 | 0 | 0 |
    | 0 | 0 | 1 | 0 |
    | 0 | 1 | 0 | 0 |
    | 1 | 0 | 0 | 0 |
    | 0 | 1 | 1 | 1 |
    | 1 | 0 | 1 | 1 |
    | 1 | 1 | 0 | 1 |
    | 1 | 1 | 1 | 1 |

    #+begin_example
      L = A'BC + AB'C + ABC' + ABC
        = AC + BC + AB
    #+end_example

    
** 最小项
*** 用卡诺图法将逻辑函数变成最小项的形式

    1. 将函数表现在卡诺图里
    2. 将卡诺图中的 1 与下面 2 图比对
       | AB\CD | 00 | 01 | 11 | 10 |
       |    00 |  0 |  1 |  3 |  2 |
       |    01 |  4 |  5 |  7 |  6 |
       |    11 | 12 | 13 | 15 | 14 |
       |    10 |  8 |  9 | 11 | 10 |

       | A\BC | 00 | 01 | 11 | 10 |
       |    0 |  0 |  1 |  3 |  2 |
       |    1 |  4 |  5 |  7 |  6 |



    题 1:
    用卡诺图法将逻辑函数 ~L = A'B + B'C'D~ 变成最小项的形式
    ~L = A'B + B'C'D~

    ~L = m1 + m4 + m5 + m6 + m7 + m9~

    题 2: 
    ~L = AB + A'C~

    ~L = m1 + m3 + m6 + m7~

*** 用公式法将逻辑函数变成最小项的形式
    1. 利用 ~A(B' + B) = A~, 令每一项都包含全部代号
    2. 整理 1 的结果, 令每一项都是 A, B, C, D 的顺序
    3. 将每一项的 A, B, C, D 变成 1, 将 A', B', C', D'变成 0
    4. 将 3 的结果由二进制数变成十进制数
    5. 在 m 后加上 4 的结果
    
    题: ~L = AB + A'C~
    #+begin_example
      L = AB + A'C
        = AB(C + C') + A'C(B + B')
        = ABC + ABC' + A'BC + A'B'C
          110   110    011    001
          7     6      3      1
        = m7 + m6 + m3 + m1
    #+end_example

*** 将最小项的形式画成变量形式
    1. 取出 m 后的数字
    2. 将数字变成二进制数(3 输入变 3 位, 4 输入变 4 位)
    3. 每一个二进制数的第一个数 0 变成 A', 1 则变成 A, 第二个数变 B 或 B'...
    4. 用公式法或者卡诺图法化简逻辑函数

    题 1:
    ~L(ABC) = m7 + m6 + m3 + m1~
    #+begin_example
      L(ABC) = m7 + m6 + m3 + m1
               7     6    3    1
               111  110  011   001
             = ABC + ABC' + A'BC + A'B'C
             = A'C + AB
    #+end_example

    题 2:
    ~L(A, B, C, D) = m1 + m4 + m5 + m6 + m7 + m9~
    
    #+begin_example
      L(A, B, C, D) = m1 + m4 + m5 + m6 + m7 + m9
                       1    4    5    6    7    9
                      0001 0100 0101 0110 0111 1001
                    = A'B'C'D + A'BC'D' + A'BC'D + A'BCD' + A'BCD + AB'C'D
                    = A'B = B'C'D
    #+end_example

*** 将求和式子用卡诺图化简

    1. 根据下图, 在 m 对应处写 1, d 对应处写 X, 其他写 0
       | AB\CD | 00 | 01 | 11 | 10 |
       |    00 |  0 |  1 |  3 |  2 |
       |    01 |  4 |  5 |  7 |  6 |
       |    11 | 12 | 13 | 15 | 14 |
       |    10 |  8 |  9 | 11 | 10 |

       | A\BC | 00 | 01 | 11 | 10 |
       |    0 |  0 |  1 |  3 |  2 |
       |    1 |  4 |  5 |  7 |  6 |
    2. 将卡诺图表示成逻辑表达式

       
    *注意*: 
    1. 表示的过程中, 可以将 X 作为 1 的补充来凑项
    2. X 仅能补充, 1 凑完即丢

    题: ~L(ABCD) = ∑m(1,4,5,6,7,9) + ∑(10,11,12,13,14,15)~

    #+begin_example
      L= B + C'D
    #+end_example
