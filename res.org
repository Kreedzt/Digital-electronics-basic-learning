* 数字电路
** 数制及转换
*** 十进制(D)转成二进制(B)
    #+begin_example
      22.8125

      整数部分:
      22 = 2 * 11 + 0 ... 0
      11 = 2 * 5 + 1 .... 1
       5 = 2 * 2 + 1 .... 1
       2 = 2 * 1 + 0 .... 0
       1 = 2 * 0 + 1 .... 1

      从下往上:
      10110

      小数部分:
      0.8125 * 2 = 1.625 ... 1
       0.625 * 2 = 1.25 .... 1
        0.25 * 2 = 0.5 ..... 0
         0.5 * 2 = 1 ....... 1

      从上往下:
      1101

      结果:
      (22.8125)D = (10110.1101)B
    #+end_example

    1. 整数部分与 2 相除, 取出余数作为标识
    2. 与 2 相除的商作为下一个与 2 相除的被除数
    3. 重复 1-2, 直到商为 0
    4. 标识倒序排列即为整数部分
    5. 小数部分与 2 相乘, 结果大于 1 则取 1 作为标识, 否则取 0
    6. 结果的小数部分作为下一个与 2 相乘的项
    7. 重复 5-6, 直到结果没有小数部分为止
    8. 标识项正序排列即为小数部分
    9. 与整数部分合并

*** 将二进制(B)转成八进制(O)
    #+begin_example
      (110010.1101)D

      110 010 . 110 1

      110 010 . 110 100

      6 2 . 6 4

      (110010.1101)B = (62.64)O
    #+end_example

    1. 以小数点开始分割, 没三项一组, 不足补 0
    2. 把每组数转成十进制数
    3. 合并结果

*** 将八进制(O)转成二进制(B)
    #+begin_example
      (62.64)O

      62.64

      6 2 . 6 4
      110 010 . 110 100
      (62.64)O = (110010.110100)B
    #+end_example

    1. 以小数点开始分割每一个数
    2. 将每一个数转成 3 位二进制, 不够补 0
    3. 合并结果(删去无用 0)

*** 将二进制(B)转成十六进制(H)
    #+begin_example
      (1100001.1101)B

      110 0001 . 1101

      0110 0001 . 1101

      6  1  .  13

      6  1  .  D

      (1100001.1101)B = (61.D)H
    #+end_example

    1. 以小数点开始分割, 每 4 位为一组, 不足补 0
    2. 将每组数转成十进制数
    3. 将溢出的十进制转成十六进制
    4. 合并结果

*** 将十六进制(H)转成二进制(B)
    #+begin_example
      (61.D)H

      61.D

      6  1  .  D

      6  1  .  13

      0110  0001  .  1101

      (61.D)H = (1100001.1101)B
    #+end_example


    1. 以小数点开始分割每一个数
    2. 将每个数转成十进制
    3. 将每个数转成 4 位二进制, 不足补 0
    4. 合并结果

*** 要点
    1. 二进制: B, 八进制: O, 十进制: D, 十六进制: H 
    2. 二进制 互转 十进制, 二进制 互转 八进制, 二进制转换十六进制

       十进制转十六进制: 先转成二进制, 再转十六进制

       八进制转十进制: 先转成二进制, 再转十进制
** 逻辑门电路
*** 基本逻辑门
    [[./img/基本逻辑图.png]]

*** 函数表达式的逻辑门
    [[./img/函数表达式逻辑图.png]]
    
*** 给出函数表达式, 画逻辑图
    [[./img/逻辑门题1步骤1.png]]

    [[./img/逻辑门题1步骤2.png]]

** 化简逻辑表达式
*** 将卡诺图表示成逻辑表达式   
    [[./img/化简题1步骤1.png]]

    | AB\CD | 00 | 01 | 11 | 10 |
    |    00 |  1 |  0 |  1 |  1 |
    |    01 |  1 |  0 |  1 |  1 |
    |    11 |  0 |  1 |  1 |  1 |
    |    10 |  0 |  0 |  1 |  1 |

    
    ~L = C + A'D' + ABD~

    [[./img/化简题2步骤1.png]]

    | A\BC | 00 | 01 | 11 | 10 |
    |    0 |  0 |  0 |  1 |  0 |
    |    1 |  0 |  1 |  1 |  1 |

    ~L = AC + BC + AB~

*** 将逻辑表达式画进卡诺图
    #+begin_example
    L = AC = A'D' + CD' + A'C + ABD
    #+end_example

    | AB\CD | 00 | 01 | 11 | 10 |
    |    00 |  1 |  0 |  1 |  1 |
    |    01 |  1 |  0 |  1 |  1 |
    |    11 |  0 |  1 |  1 |  1 |
    |    10 |  0 |  0 |  1 |  1 |

    #+begin_example
    L = A'BC + AB'C + ABC' + ABC
    #+end_example

    | A\BC | 00 | 01 | 11 | 10 |
    |    0 |  0 |  0 |  1 |  0 |
    |    1 |  0 |  1 |  1 |  1 |

*** 用卡诺图化简逻辑表达式
    #+begin_example
      L = AC + A'D' + CD' + A'C + ABD
    #+end_example

    | AB\CD | 00 | 01 | 11 | 10 |
    |    00 |  1 |  0 |  1 |  1 |
    |    01 |  1 |  0 |  1 |  1 |
    |    11 |  0 |  1 |  1 |  1 |
    |    10 |  0 |  0 |  1 |  1 |

    ~L = C + ABD + A'D'~

    #+begin_example
    L = A'BC + AB'C + ABC' + ABC
    #+end_example

    | A\BC | 00 | 01 | 11 | 10 |
    |    0 |  0 |  0 |  1 |  0 |
    |    1 |  0 |  1 |  1 |  1 |

    ~L = AC + BC + AB~

*** 用公式法化简逻辑表达式

    [[./img/公式.png]]
    
    | 名称   | 公式 1                                   | 公式 2                    |
    | 0-1 律 | A * 1 = A                                | A + 0 = A                 |
    |        | A* 0 + 0                                 | A + 1 = 1                 |
    | 互补律 | AA' = 0                                  | A + A' = 1                |
    | 重叠律 | AA = A                                   | A + A = A                 |
    | 交换律 | AB = BA                                  | A + B = B + A             |
    | 结合律 | A(BC) = (AB)C                            | A + (B + C) = (A + B) + C |
    | 分配律 | (A + B)C = AC + BC                       | AB + C = (A + C)(B + C)   |
    | 反演律 | (AB)' = A' + B'                          | (A + B)' = A'B'           |
    | 吸收律 | A(A + B) = A                             | A + AB = A                |
    |        | A(A' + B) = AB                           | A + A'B = A + B           |
    |        | (A + B)(A' + C)(B + C) = (A + B)(A' + C) | AB + A'C + BC = AB + A'C  |
    | 对合律 | A'' = A                                  |                           |

    记忆技巧:
    #+begin_example
      公式1 <=> 公式2

      与 -> 或
      或 -> 与

      0 -> 1
      1 -> 0
    #+end_example

    #+begin_example
      L = A'BC + AB'C + ABC' + ABC
        = A'BC + AB'C + ABC' + ABC + ABC + ABC
        = (A'BC + ABC) + (AB'C + ABC) + (ABC' + ABC)
        = BC(A' + A) + AC(B' + B) + AB(C' + C)
        = BC + AC = AB
    #+end_example

*** 求公式表示函数的反函数
    1. 与 -> 或, 或 -> 与
    2. 0 -> 1, 1 -> 0
    3. 原变量 -> 反变量
    4. 反变量 -> 原变量
    5. 多个变量的公共非号保持不变
    6. 原式运算的优先顺序保持不变

       
    #+begin_example
      L = A + BC' + (ACD')'
        = A' * (B'+ C) * (A' + C' + D)'
    #+end_example

    

*** 求卡诺图表示函数的反函数
    | AB\CD | 00 | 01 | 11 | 10 |
    |    00 |  1 |  1 |  1 |  1 |
    |    01 |  0 |  1 |  1 |  1 |
    |    11 |  0 |  1 |  1 |  1 |
    |    10 |  1 |  1 |  1 |  1 |

    把 0 当 1, 1 当 0 看即反函数
    ~L' = BC'D'~

** 组合逻辑电路的分析与设计
*** 给出逻辑电路图, 分析逻辑功能
    1. 由逻辑图写出函数表达式
    2. 化简函数表达式
    3. 列出所有情况
    4. 分析出功能

       
    [[./img/逻辑电路图图1.png]]

    [[./img/逻辑电路图图1步骤2.png]]

    [[./img/逻辑电路图图1步骤3.png]]

    #+begin_example
      L = A(ABC)' + B(ABC)' + C(ABC)'
        = A(A' + B' + C') + B(A' + B' + C') + C(A' + B' + C')
        = AA' + AB' + AC' + A'B + BB' + BC' + A'C + B'C + CC'
        = AB' + AC' + A'B + BC' +  A'C + B'C

        由卡诺图得:
        = AB' + A'C + BC'
    #+end_example

    | A | B | C | L |
    | 0 | 0 | 0 | 0 |
    | 0 | 0 | 1 | 1 |
    | 0 | 1 | 0 | 1 |
    | 1 | 0 | 0 | 1 |
    | 0 | 1 | 1 | 1 |
    | 1 | 0 | 1 | 1 |
    | 1 | 1 | 0 | 1 |
    | 1 | 1 | 1 | 0 |

    由真值表可知, 当 A, B, C 不一致时, 电路输出为 "1", 所以, 这个电路为 "不一致
    电路"

*** 三种常考电路
    | A | B | C | L |
    | 0 | 0 | 0 | 0 |
    | 0 | 0 | 1 | 1 |
    | 0 | 1 | 0 | 1 |
    | 1 | 0 | 0 | 1 |
    | 0 | 1 | 1 | 1 |
    | 1 | 0 | 1 | 1 |
    | 1 | 1 | 0 | 1 |
    | 1 | 1 | 1 | 0 |

    不一致电路

    
    | A | B | C | L |
    | 0 | 0 | 0 | 1 |
    | 0 | 0 | 1 | 0 |
    | 0 | 1 | 0 | 0 |
    | 1 | 0 | 0 | 0 |
    | 0 | 1 | 1 | 0 |
    | 1 | 0 | 1 | 0 |
    | 1 | 1 | 0 | 0 |
    | 1 | 1 | 1 | 1 |

    一致电路

    | A | B | C | L |
    | 0 | 0 | 0 | 0 |
    | 0 | 0 | 1 | 0 |
    | 0 | 1 | 0 | 0 |
    | 1 | 0 | 0 | 0 |
    | 0 | 1 | 1 | 1 |
    | 1 | 0 | 1 | 1 |
    | 1 | 1 | 0 | 1 |
    | 1 | 1 | 1 | 1 |

    少数服从多数电路

    
*** 给出功能要求, 设计电路
    设计一个三人表决电路, 结果按 "少数服从多数" 原则决定

    1. 确定输入个数, 定义 0, 1
    2. 列真值表
    3. 写出逻辑表达式
    4. 化简
    5. 画出电路图

       
    | A | B | C | L |
    | 0 | 0 | 0 | 0 |
    | 0 | 0 | 1 | 0 |
    | 0 | 1 | 0 | 0 |
    | 1 | 0 | 0 | 0 |
    | 0 | 1 | 1 | 1 |
    | 1 | 0 | 1 | 1 |
    | 1 | 1 | 0 | 1 |
    | 1 | 1 | 1 | 1 |

    #+begin_example
      L = A'BC + AB'C + ABC' + ABC
        = AC + BC + AB
    #+end_example

** 最小项
*** 用卡诺图法将逻辑函数变成最小项的形式

    1. 将函数表现在卡诺图里
    2. 将卡诺图中的 1 与下面 2 图比对
       | AB\CD | 00 | 01 | 11 | 10 |
       |    00 |  0 |  1 |  3 |  2 |
       |    01 |  4 |  5 |  7 |  6 |
       |    11 | 12 | 13 | 15 | 14 |
       |    10 |  8 |  9 | 11 | 10 |

       | A\BC | 00 | 01 | 11 | 10 |
       |    0 |  0 |  1 |  3 |  2 |
       |    1 |  4 |  5 |  7 |  6 |



    题 1:
    用卡诺图法将逻辑函数 ~L = A'B + B'C'D~ 变成最小项的形式
    ~L = A'B + B'C'D~

    ~L = m1 + m4 + m5 + m6 + m7 + m9~

    题 2: 
    ~L = AB + A'C~

    ~L = m1 + m3 + m6 + m7~

*** 用公式法将逻辑函数变成最小项的形式
    1. 利用 ~A(B' + B) = A~, 令每一项都包含全部代号
    2. 整理 1 的结果, 令每一项都是 A, B, C, D 的顺序
    3. 将每一项的 A, B, C, D 变成 1, 将 A', B', C', D'变成 0
    4. 将 3 的结果由二进制数变成十进制数
    5. 在 m 后加上 4 的结果
    
    题: ~L = AB + A'C~
    #+begin_example
      L = AB + A'C
        = AB(C + C') + A'C(B + B')
        = ABC + ABC' + A'BC + A'B'C
          110   110    011    001
          7     6      3      1
        = m7 + m6 + m3 + m1
    #+end_example

*** 将最小项的形式画成变量形式
    1. 取出 m 后的数字
    2. 将数字变成二进制数(3 输入变 3 位, 4 输入变 4 位)
    3. 每一个二进制数的第一个数 0 变成 A', 1 则变成 A, 第二个数变 B 或 B'...
    4. 用公式法或者卡诺图法化简逻辑函数

    题 1:
    ~L(ABC) = m7 + m6 + m3 + m1~
    #+begin_example
      L(ABC) = m7 + m6 + m3 + m1
               7     6    3    1
               111  110  011   001
             = ABC + ABC' + A'BC + A'B'C
             = A'C + AB
    #+end_example

    题 2:
    ~L(A, B, C, D) = m1 + m4 + m5 + m6 + m7 + m9~
    
    #+begin_example
      L(A, B, C, D) = m1 + m4 + m5 + m6 + m7 + m9
                       1    4    5    6    7    9
                      0001 0100 0101 0110 0111 1001
                    = A'B'C'D + A'BC'D' + A'BC'D + A'BCD' + A'BCD + AB'C'D
                    = A'B = B'C'D
    #+end_example

*** 将求和式子用卡诺图化简

    1. 根据下图, 在 m 对应处写 1, d 对应处写 X, 其他写 0
       | AB\CD | 00 | 01 | 11 | 10 |
       |    00 |  0 |  1 |  3 |  2 |
       |    01 |  4 |  5 |  7 |  6 |
       |    11 | 12 | 13 | 15 | 14 |
       |    10 |  8 |  9 | 11 | 10 |

       | A\BC | 00 | 01 | 11 | 10 |
       |    0 |  0 |  1 |  3 |  2 |
       |    1 |  4 |  5 |  7 |  6 |
    2. 将卡诺图表示成逻辑表达式

       
    *注意*: 
    1. 表示的过程中, 可以将 X 作为 1 的补充来凑项
    2. X 仅能补充, 1 凑完即丢

    题: ~L(ABCD) = ∑m(1,4,5,6,7,9) + ∑(10,11,12,13,14,15)~

    #+begin_example
      L= B + C'D
    #+end_example
** 常用集成器件
    - 74138
      [[./img/74138.png]]
    
    - 74151
      [[./img/74151.png]]


*** 使用译码器和门电路实现逻辑函数
    1. 下边左三: 带圈输入 0, 不带圈输入 1(G1, G2A, G2B)
    2. 下边右三: 依次写入三个输入量(多为 A, B, C)
    3. 将函数画成最小项形式
    4. 将 ~m~ 变成 ~Y'~, ~m'~ 变成 ~Y~
    5. 利用如下公式, 化简结果里单独的 ~Y'~
       - ~Y1' + Y2' = (Y1Y2)'~
       - ~Y1'Y2' = (Y1+Y2)'~
       - 根据函数与 Y 的关系接线

         
    题 1:
    [[./img/常用集成器件题1.png]]
         
    #+begin_example
      L = AB + BC + AC
        = A'BC + AB'C + ABC' + ABC
        = m3 + m5 + m6 + m7
        = Y3' + Y5' + Y6' + Y7'
    #+end_example
    

*** 根据译码器接线图写出逻辑函数

    1. 根据接线写出函数与 Y 的关系式
    2. 将 ~Y~ 变成 ~m'~
    3. 若最小项中存在 ~(一堆东西)'~ 的情况, 使用如下公式化简
       - ~(m1m2)' = m1' + m2'~
       - ~(m1 + m2)' = m1'm2'~
    4. 将最小项变成表达式
    5. 化简表达式

    题 1:
    [[./img/常用集成器件题1.png]]

    #+begin_example
      L = (Y3Y5Y6Y7)'
        = (m3'm5'm6'm7')'
        = m3'' + m5'' + m6'' + m7''
        = m3 + m5 + m6 + m7
          011  101  110  111
        = A'BC + AB'C + ABC' + ABC
        = AB + BC + AC
    #+end_example

*** 使用 8 选 1 数据选择器实现 3 输入逻辑函数
    1. 下边左一(G): 带圈则接地/输入 0, 若不带圈输入 1
    2. 下边中三(A2A1A0): 一次写入三个输入量(多为 A,B,C)
    3. 将函数画成最小项形式
    4. 将 m 变成 D
    5. 下边: 将上步出现的 D 引出来接 1, 没出现的 D 引出来接 0
    6. 上边: Y 输出的是上一步接 1 的 D 相或
           Y'输出的是上一步中接 1 的 D 相或

    题 1: 使用 74151 实现逻辑函数 ~L=A'BC + AB'C + ABC~

    [[./img/常用集成器件题2.png]]
    
    #+begin_example
      L = A'BC + AB'C + ABC
        = m3 + m5 + m7
        = D3 + D5 + D7
    #+end_example

*** 使用 8 选 1 数据选择器实现多输入逻辑函数
    1. 下边左一(G): 带圈则接地/输入 0, 若不带圈输入 1
    2. 下边中三(A2A1A0): 一次写入三个输入量(多为 A,B,C)
    3. 无视函数中 ~ABC~ 以外输入, 将 ABC 画成最小项形式
    4. 将 m 变成 D
    5. 下边: 
       - 将上步没出现的 D 引出来接 0
       - 前面没乘字母的 D 引出来接 1
       - 前面乘上字母 N 的 D 引出来接 N
       - ...同上
    6. 上边: Y 输出的是:
       #+begin_src text
         {
           接1的那些D    
           接字母的那些D * 字母
         } 相或
       #+end_src
       Y'输出(Y')内容
    7. 根据表达式选择一个写上 L

       
    题 1:
    使用 8 选 1 选择器 74151 实现逻辑函数: ~L = A'B'C + AB'CD + A'BCD' + ABCE~

    [[./img/常用集成器件题2解答.png]]

    #+begin_example
      L = A'B'C + AB'CD + A'BCD' + ABCE
           001    101     011      111
        =  m1  +  m5 * D + m3 * D'  + m7 * E
        =  D1  +  D5 * D + D3 * D'  + D7 * E
    #+end_example

*** 使用 8 选 1 数据选择器实现 ~L = ∑m~ 格式的 3 输入逻辑函数
    1. 下边左一(G): 带圈则接地/输入 0, 若不带圈输入 1
    2. 下边中三(A2A1A0): 一次写入三个输入量(多为 A,B,C)
    3. 将∑m 后的括号展开
    4. 将 m 变成 D
    5. 下边: 
       - 将上步没出现的 D 引出来接 0
       - 前面没乘字母的 D 引出来接 1
    6. 上边: Y 输入的是上一步中接 1 的 D 相或
    7. 根据表达式选择一个写上 L

    题 1: 使用 74151 实现 ~L = F(A,B,C) = ∑m(3, 5, 7)~

    [[./img/常用集成器件题5解答.png]]

    #+begin_example
      L = F(A,B,C) = ∑m(3, 5, 7)
        = m3 + m5 + m7
        = D3 + D5 + D7
    #+end_example

*** 使用 8 选 1 数据选择器实现 ~L = ∑m~ 格式的 3 输入逻辑函数
    1. 下边左一(G): 带圈则接地/输入 0, 若不带圈输入 1
    2. 下边中三(A2A1A0): 一次写入三个输入量(多为 A,B,C)
    3. 将∑m 后的括号展开
    4. 将 m 变成 逻辑函数
    5. 无视函数中 ~ABC~ 以外的输入, 将 ~ABC~ 画成最小项形式
    6. 将 m 变成 D
    7. 下边: 
       - 将上步没出现的 D 引出来接 0
       - 前面没乘字母的 D 引出来接 1
       - 前面乘上字母 N 的 D 引出来接 N
       - ...同上
    8. 上边: Y 输出的是:
       #+begin_src text
         {
           接1的那些D    
           接字母的那些D * 字母
         } 相或
       #+end_src
       Y'输出(Y')内容
    9. 根据表达式选择一个写上 L

    题 1: 使用 74151 实现 ~L = F(A,B,C, D) = ∑m(0, 3, 5, 8, 13, 15)~

    [[./img/常用集成器件题6解答.png]]


    #+begin_example
      L = F(A,B,C, D) = ∑m(0, 3, 5, 8, 13, 15)
        = m0 + m3 + m5 + m8 + m13 + m15
          0000 0001 0101 1000 1101 1111
        = A'B'C'D' + A'B'CD + A'BC'D + AB'C'D' + ABC'D + ABCD
          000        001      010      100       110      111
        = m0 * D' + m1 * D + m2 * D + m4 * D' + m6 * D + m7 * D
        = D(m1 + m2 + m6 + m7) + D'(m0 + m4)
        = D(D1 + D2 + D6 + D7) + D'(D0 + D4)
    #+end_example
** 触发器
*** 给出 D 触发器及输入, 要求画出波形图
    [[./img/触发器题1.png]]
    
    1. 在 CP 凸起左侧或右侧向下画虚线
       1) 若 C1 接口处无"o", 则在左侧
       2) 若 C1 接口处有"o", 则在右侧
    2. 判断每个虚线处输入变量的值是 0 还是 1(若判断不出, 取稍左偏移的值)
    3. 判断每个虚线处输入变量变量的值是有效还是无效, 若可使进入触发器的值为 1, 则
       有效, 反之无效
    4. 根据下标, 得出 Q 的值, 并画在图上
       | 进入触发器的值 | Q 在虚线右侧的值 Q^(n+1) |
       |----------------+--------------------------|
       | 有效           |                        1 |
       | 无效           |                        0 |

    [[./img/触发器题1步骤1.png]]

    [[./img/触发器题1步骤2.png]]
    
    [[./img/触发器题1步骤3.png]]

    [[./img/触发器题1步骤4.png]]

    *Tips*: 
    1. 因为 D 触发器初始状态为 0, 所以 Q 起始值为 0
    2. Q 与 Q'输出值永远想反
    3. D 触发器的特性方程:
       #+begin_example
       Q^(n+1) = D
       #+end_example

*** 给出 JK 触发器及输入, 要求画出波形图
    [[./img/触发器题2.png]]

    1. 在 CP 凸起左侧或右侧向下画虚线
       1) 若 C1 接口处无"o", 则在左侧
       2) 若 C1 接口处有"o", 则在右侧
    2. 判断每个虚线处输入变量的值是 0 还是 1(若判断不出, 取稍左偏移的值)
    3. 判断每个虚线处输入变量变量的值是有效还是无效, 若可使进入触发器的值为 1, 则有效, 反之无效
    4. 根据下表, 得出 Q 的值, 并画在图上
       | J    | K    | Q 在虚线左边的值 Q^n | Q 在虚线右边的值 Q^(n+1) |
       |------+------+----------------------+--------------------------|
       | 有效 | 无效 |                    0 |                        1 |
       |      |      |                    1 |                        1 |
       |------+------+----------------------+--------------------------|
       | 无效 | 有效 |                    0 |                        0 |
       |      |      |                    1 |                        0 |
       |------+------+----------------------+--------------------------|
       | 无效 | 无效 |                    0 |                        0 |
       |      |      |                    1 |                        1 |
       |------+------+----------------------+--------------------------|
       | 有效 | 有效 |                    0 |                        1 |
       |      |      |                    1 |                        0 |

       

    [[./img/触发器题2步骤1.png]]

    
    [[./img/触发器题2步骤2.png]]

    *Tips*:
    1. 结论表简便记忆表:
       | J    | K    | Q^(n+1) |
       |------+------+---------|
       | 有效 | 无效 | 1       |
       | 无效 | 有效 | 0       |
       | 无效 | 无效 | 不变    |
       | 有效 | 有效 | 相反    |
    
    2. 1K 为复位端, 1J 为置位端

    3. 特性方程:
       #+begin_example
       Q^(n+1) = J * (Q^n)' + K' * Q^n
       #+end_example


*** 多个触发器相连    
    [[./img/触发器题3.png]]
    
    
    [[./img/触发器题3步骤1.png]]

    [[./img/触发器题3步骤2.png]]
    
