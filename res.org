* 数字电路
** 数制及转换
*** 十进制(D)转成二进制(B)
    #+begin_example
      22.8125

      整数部分:
      22 = 2 * 11 + 0 ... 0
      11 = 2 * 5 + 1 .... 1
       5 = 2 * 2 + 1 .... 1
       2 = 2 * 1 + 0 .... 0
       1 = 2 * 0 + 1 .... 1

      从下往上:
      10110

      小数部分:
      0.8125 * 2 = 1.625 ... 1
       0.625 * 2 = 1.25 .... 1
        0.25 * 2 = 0.5 ..... 0
         0.5 * 2 = 1 ....... 1

      从上往下:
      1101

      结果:
      (22.8125)D = (10110.1101)B
    #+end_example

    1. 整数部分与 2 相除, 取出余数作为标识
    2. 与 2 相除的商作为下一个与 2 相除的被除数
    3. 重复 1-2, 直到商为 0
    4. 标识倒序排列即为整数部分
    5. 小数部分与 2 相乘, 结果大于 1 则取 1 作为标识, 否则取 0
    6. 结果的小数部分作为下一个与 2 相乘的项
    7. 重复 5-6, 直到结果没有小数部分为止
    8. 标识项正序排列即为小数部分
    9. 与整数部分合并

*** 将二进制(B)转成八进制(O)
    #+begin_example
      (110010.1101)D

      110 010 . 110 1

      110 010 . 110 100

      6 2 . 6 4

      (110010.1101)B = (62.64)O
    #+end_example

    1. 以小数点开始分割, 没三项一组, 不足补 0
    2. 把每组数转成十进制数
    3. 合并结果

*** 将八进制(O)转成二进制(B)
    #+begin_example
      (62.64)O

      62.64

      6 2 . 6 4
      110 010 . 110 100
      (62.64)O = (110010.110100)B
    #+end_example

    1. 以小数点开始分割每一个数
    2. 将每一个数转成 3 位二进制, 不够补 0
    3. 合并结果(删去无用 0)

*** 将二进制(B)转成十六进制(H)
    #+begin_example
      (1100001.1101)B

      110 0001 . 1101

      0110 0001 . 1101

      6  1  .  13

      6  1  .  D

      (1100001.1101)B = (61.D)H
    #+end_example

    1. 以小数点开始分割, 每 4 位为一组, 不足补 0
    2. 将每组数转成十进制数
    3. 将溢出的十进制转成十六进制
    4. 合并结果

*** 将十六进制(H)转成二进制(B)
    #+begin_example
      (61.D)H

      61.D

      6  1  .  D

      6  1  .  13

      0110  0001  .  1101

      (61.D)H = (1100001.1101)B
    #+end_example


    1. 以小数点开始分割每一个数
    2. 将每个数转成十进制
    3. 将每个数转成 4 位二进制, 不足补 0
    4. 合并结果

*** 要点
    1. 二进制: B, 八进制: O, 十进制: D, 十六进制: H 
    2. 二进制 互转 十进制, 二进制 互转 八进制, 二进制转换十六进制

       十进制转十六进制: 先转成二进制, 再转十六进制

       八进制转十进制: 先转成二进制, 再转十进制
** 逻辑门电路
*** 基本逻辑门
    [[./img/基本逻辑图.png]]

*** 函数表达式的逻辑门
    [[./img/函数表达式逻辑图.png]]
    
*** 给出函数表达式, 画逻辑图
    [[./img/逻辑门题1步骤1.png]]

    [[./img/逻辑门题1步骤2.png]]

** 化简逻辑表达式
*** 将卡诺图表示成逻辑表达式   
    [[./img/化简题1步骤1.png]]

    | AB\CD | 00 | 01 | 11 | 10 |
    |    00 |  1 |  0 |  1 |  1 |
    |    01 |  1 |  0 |  1 |  1 |
    |    11 |  0 |  1 |  1 |  1 |
    |    10 |  0 |  0 |  1 |  1 |

    
    ~L = C + A'D' + ABD~

    [[./img/化简题2步骤1.png]]

    | A\BC | 00 | 01 | 11 | 10 |
    |    0 |  0 |  0 |  1 |  0 |
    |    1 |  0 |  1 |  1 |  1 |

    ~L = AC + BC + AB~

*** 将逻辑表达式画进卡诺图
    #+begin_example
    L = AC = A'D' + CD' + A'C + ABD
    #+end_example

    | AB\CD | 00 | 01 | 11 | 10 |
    |    00 |  1 |  0 |  1 |  1 |
    |    01 |  1 |  0 |  1 |  1 |
    |    11 |  0 |  1 |  1 |  1 |
    |    10 |  0 |  0 |  1 |  1 |

    #+begin_example
    L = A'BC + AB'C + ABC' + ABC
    #+end_example

    | A\BC | 00 | 01 | 11 | 10 |
    |    0 |  0 |  0 |  1 |  0 |
    |    1 |  0 |  1 |  1 |  1 |

*** 用卡诺图化简逻辑表达式
    #+begin_example
      L = AC + A'D' + CD' + A'C + ABD
    #+end_example

    | AB\CD | 00 | 01 | 11 | 10 |
    |    00 |  1 |  0 |  1 |  1 |
    |    01 |  1 |  0 |  1 |  1 |
    |    11 |  0 |  1 |  1 |  1 |
    |    10 |  0 |  0 |  1 |  1 |

    ~L = C + ABD + A'D'~

    #+begin_example
    L = A'BC + AB'C + ABC' + ABC
    #+end_example

    | A\BC | 00 | 01 | 11 | 10 |
    |    0 |  0 |  0 |  1 |  0 |
    |    1 |  0 |  1 |  1 |  1 |

    ~L = AC + BC + AB~

*** 用公式法化简逻辑表达式

    [[./img/公式.png]]
    
    | 名称   | 公式 1                                   | 公式 2                    |
    | 0-1 律 | A * 1 = A                                | A + 0 = A                 |
    |        | A* 0 + 0                                 | A + 1 = 1                 |
    | 互补律 | AA' = 0                                  | A + A' = 1                |
    | 重叠律 | AA = A                                   | A + A = A                 |
    | 交换律 | AB = BA                                  | A + B = B + A             |
    | 结合律 | A(BC) = (AB)C                            | A + (B + C) = (A + B) + C |
    | 分配律 | (A + B)C = AC + BC                       | AB + C = (A + C)(B + C)   |
    | 反演律 | (AB)' = A' + B'                          | (A + B)' = A'B'           |
    | 吸收律 | A(A + B) = A                             | A + AB = A                |
    |        | A(A' + B) = AB                           | A + A'B = A + B           |
    |        | (A + B)(A' + C)(B + C) = (A + B)(A' + C) | AB + A'C + BC = AB + A'C  |
    | 对合律 | A'' = A                                  |                           |

    记忆技巧:
    #+begin_example
      公式1 <=> 公式2

      与 -> 或
      或 -> 与

      0 -> 1
      1 -> 0
    #+end_example

    #+begin_example
      L = A'BC + AB'C + ABC' + ABC
        = A'BC + AB'C + ABC' + ABC + ABC + ABC
        = (A'BC + ABC) + (AB'C + ABC) + (ABC' + ABC)
        = BC(A' + A) + AC(B' + B) + AB(C' + C)
        = BC + AC = AB
    #+end_example

*** 求公式表示函数的反函数
    1. 与 -> 或, 或 -> 与
    2. 0 -> 1, 1 -> 0
    3. 原变量 -> 反变量
    4. 反变量 -> 原变量
    5. 多个变量的公共非号保持不变
    6. 原式运算的优先顺序保持不变

       
    #+begin_example
      L = A + BC' + (ACD')'
        = A' * (B'+ C) * (A' + C' + D)'
    #+end_example

    

*** 求卡诺图表示函数的反函数
    | AB\CD | 00 | 01 | 11 | 10 |
    |    00 |  1 |  1 |  1 |  1 |
    |    01 |  0 |  1 |  1 |  1 |
    |    11 |  0 |  1 |  1 |  1 |
    |    10 |  1 |  1 |  1 |  1 |

    把 0 当 1, 1 当 0 看即反函数
    ~L' = BC'D'~

** 组合逻辑电路的分析与设计
*** 给出逻辑电路图, 分析逻辑功能
    1. 由逻辑图写出函数表达式
    2. 化简函数表达式
    3. 列出所有情况
    4. 分析出功能

       
    [[./img/逻辑电路图图1.png]]

    [[./img/逻辑电路图图1步骤2.png]]

    [[./img/逻辑电路图图1步骤3.png]]

    #+begin_example
      L = A(ABC)' + B(ABC)' + C(ABC)'
        = A(A' + B' + C') + B(A' + B' + C') + C(A' + B' + C')
        = AA' + AB' + AC' + A'B + BB' + BC' + A'C + B'C + CC'
        = AB' + AC' + A'B + BC' +  A'C + B'C

        由卡诺图得:
        = AB' + A'C + BC'
    #+end_example

    | A | B | C | L |
    | 0 | 0 | 0 | 0 |
    | 0 | 0 | 1 | 1 |
    | 0 | 1 | 0 | 1 |
    | 1 | 0 | 0 | 1 |
    | 0 | 1 | 1 | 1 |
    | 1 | 0 | 1 | 1 |
    | 1 | 1 | 0 | 1 |
    | 1 | 1 | 1 | 0 |

    由真值表可知, 当 A, B, C 不一致时, 电路输出为 "1", 所以, 这个电路为 "不一致
    电路"

*** 三种常考电路
    | A | B | C | L |
    | 0 | 0 | 0 | 0 |
    | 0 | 0 | 1 | 1 |
    | 0 | 1 | 0 | 1 |
    | 1 | 0 | 0 | 1 |
    | 0 | 1 | 1 | 1 |
    | 1 | 0 | 1 | 1 |
    | 1 | 1 | 0 | 1 |
    | 1 | 1 | 1 | 0 |

    不一致电路

    
    | A | B | C | L |
    | 0 | 0 | 0 | 1 |
    | 0 | 0 | 1 | 0 |
    | 0 | 1 | 0 | 0 |
    | 1 | 0 | 0 | 0 |
    | 0 | 1 | 1 | 0 |
    | 1 | 0 | 1 | 0 |
    | 1 | 1 | 0 | 0 |
    | 1 | 1 | 1 | 1 |

    一致电路

    | A | B | C | L |
    | 0 | 0 | 0 | 0 |
    | 0 | 0 | 1 | 0 |
    | 0 | 1 | 0 | 0 |
    | 1 | 0 | 0 | 0 |
    | 0 | 1 | 1 | 1 |
    | 1 | 0 | 1 | 1 |
    | 1 | 1 | 0 | 1 |
    | 1 | 1 | 1 | 1 |

    少数服从多数电路

    
*** 给出功能要求, 设计电路
    设计一个三人表决电路, 结果按 "少数服从多数" 原则决定

    1. 确定输入个数, 定义 0, 1
    2. 列真值表
    3. 写出逻辑表达式
    4. 化简
    5. 画出电路图

       
    | A | B | C | L |
    | 0 | 0 | 0 | 0 |
    | 0 | 0 | 1 | 0 |
    | 0 | 1 | 0 | 0 |
    | 1 | 0 | 0 | 0 |
    | 0 | 1 | 1 | 1 |
    | 1 | 0 | 1 | 1 |
    | 1 | 1 | 0 | 1 |
    | 1 | 1 | 1 | 1 |

    #+begin_example
      L = A'BC + AB'C + ABC' + ABC
        = AC + BC + AB
    #+end_example

** 最小项
*** 用卡诺图法将逻辑函数变成最小项的形式

    1. 将函数表现在卡诺图里
    2. 将卡诺图中的 1 与下面 2 图比对
       | AB\CD | 00 | 01 | 11 | 10 |
       |    00 |  0 |  1 |  3 |  2 |
       |    01 |  4 |  5 |  7 |  6 |
       |    11 | 12 | 13 | 15 | 14 |
       |    10 |  8 |  9 | 11 | 10 |

       | A\BC | 00 | 01 | 11 | 10 |
       |    0 |  0 |  1 |  3 |  2 |
       |    1 |  4 |  5 |  7 |  6 |



    题 1:
    用卡诺图法将逻辑函数 ~L = A'B + B'C'D~ 变成最小项的形式
    ~L = A'B + B'C'D~

    ~L = m1 + m4 + m5 + m6 + m7 + m9~

    题 2: 
    ~L = AB + A'C~

    ~L = m1 + m3 + m6 + m7~

*** 用公式法将逻辑函数变成最小项的形式
    1. 利用 ~A(B' + B) = A~, 令每一项都包含全部代号
    2. 整理 1 的结果, 令每一项都是 A, B, C, D 的顺序
    3. 将每一项的 A, B, C, D 变成 1, 将 A', B', C', D'变成 0
    4. 将 3 的结果由二进制数变成十进制数
    5. 在 m 后加上 4 的结果
    
    题: ~L = AB + A'C~
    #+begin_example
      L = AB + A'C
        = AB(C + C') + A'C(B + B')
        = ABC + ABC' + A'BC + A'B'C
          110   110    011    001
          7     6      3      1
        = m7 + m6 + m3 + m1
    #+end_example

*** 将最小项的形式画成变量形式
    1. 取出 m 后的数字
    2. 将数字变成二进制数(3 输入变 3 位, 4 输入变 4 位)
    3. 每一个二进制数的第一个数 0 变成 A', 1 则变成 A, 第二个数变 B 或 B'...
    4. 用公式法或者卡诺图法化简逻辑函数

    题 1:
    ~L(ABC) = m7 + m6 + m3 + m1~
    #+begin_example
      L(ABC) = m7 + m6 + m3 + m1
               7     6    3    1
               111  110  011   001
             = ABC + ABC' + A'BC + A'B'C
             = A'C + AB
    #+end_example

    题 2:
    ~L(A, B, C, D) = m1 + m4 + m5 + m6 + m7 + m9~
    
    #+begin_example
      L(A, B, C, D) = m1 + m4 + m5 + m6 + m7 + m9
                       1    4    5    6    7    9
                      0001 0100 0101 0110 0111 1001
                    = A'B'C'D + A'BC'D' + A'BC'D + A'BCD' + A'BCD + AB'C'D
                    = A'B = B'C'D
    #+end_example

*** 将求和式子用卡诺图化简

    1. 根据下图, 在 m 对应处写 1, d 对应处写 X, 其他写 0
       | AB\CD | 00 | 01 | 11 | 10 |
       |    00 |  0 |  1 |  3 |  2 |
       |    01 |  4 |  5 |  7 |  6 |
       |    11 | 12 | 13 | 15 | 14 |
       |    10 |  8 |  9 | 11 | 10 |

       | A\BC | 00 | 01 | 11 | 10 |
       |    0 |  0 |  1 |  3 |  2 |
       |    1 |  4 |  5 |  7 |  6 |
    2. 将卡诺图表示成逻辑表达式

       
    *注意*: 
    1. 表示的过程中, 可以将 X 作为 1 的补充来凑项
    2. X 仅能补充, 1 凑完即丢

    题: ~L(ABCD) = ∑m(1,4,5,6,7,9) + ∑(10,11,12,13,14,15)~

    #+begin_example
      L= B + C'D
    #+end_example
** 常用集成器件
    - 74138
      [[./img/74138.png]]
    
    - 74151
      [[./img/74151.png]]


*** 使用译码器和门电路实现逻辑函数
    1. 下边左三: 带圈输入 0, 不带圈输入 1(G1, G2A, G2B)
    2. 下边右三: 依次写入三个输入量(多为 A, B, C)
    3. 将函数画成最小项形式
    4. 将 ~m~ 变成 ~Y'~, ~m'~ 变成 ~Y~
    5. 利用如下公式, 化简结果里单独的 ~Y'~
       - ~Y1' + Y2' = (Y1Y2)'~
       - ~Y1'Y2' = (Y1+Y2)'~
       - 根据函数与 Y 的关系接线

         
    题 1:
    [[./img/常用集成器件题1.png]]
         
    #+begin_example
      L = AB + BC + AC
        = A'BC + AB'C + ABC' + ABC
        = m3 + m5 + m6 + m7
        = Y3' + Y5' + Y6' + Y7'
    #+end_example
    

*** 根据译码器接线图写出逻辑函数

    1. 根据接线写出函数与 Y 的关系式
    2. 将 ~Y~ 变成 ~m'~
    3. 若最小项中存在 ~(一堆东西)'~ 的情况, 使用如下公式化简
       - ~(m1m2)' = m1' + m2'~
       - ~(m1 + m2)' = m1'm2'~
    4. 将最小项变成表达式
    5. 化简表达式

    题 1:
    [[./img/常用集成器件题1.png]]

    #+begin_example
      L = (Y3Y5Y6Y7)'
        = (m3'm5'm6'm7')'
        = m3'' + m5'' + m6'' + m7''
        = m3 + m5 + m6 + m7
          011  101  110  111
        = A'BC + AB'C + ABC' + ABC
        = AB + BC + AC
    #+end_example

*** 使用 8 选 1 数据选择器实现 3 输入逻辑函数
    1. 下边左一(G): 带圈则接地/输入 0, 若不带圈输入 1
    2. 下边中三(A2A1A0): 一次写入三个输入量(多为 A,B,C)
    3. 将函数画成最小项形式
    4. 将 m 变成 D
    5. 下边: 将上步出现的 D 引出来接 1, 没出现的 D 引出来接 0
    6. 上边: Y 输出的是上一步接 1 的 D 相或
           Y'输出的是上一步中接 1 的 D 相或

    题 1: 使用 74151 实现逻辑函数 ~L=A'BC + AB'C + ABC~

    [[./img/常用集成器件题2.png]]
    
    #+begin_example
      L = A'BC + AB'C + ABC
        = m3 + m5 + m7
        = D3 + D5 + D7
    #+end_example

*** 使用 8 选 1 数据选择器实现多输入逻辑函数
    1. 下边左一(G): 带圈则接地/输入 0, 若不带圈输入 1
    2. 下边中三(A2A1A0): 一次写入三个输入量(多为 A,B,C)
    3. 无视函数中 ~ABC~ 以外输入, 将 ABC 画成最小项形式
    4. 将 m 变成 D
    5. 下边: 
       - 将上步没出现的 D 引出来接 0
       - 前面没乘字母的 D 引出来接 1
       - 前面乘上字母 N 的 D 引出来接 N
       - ...同上
    6. 上边: Y 输出的是:
       #+begin_src text
         {
           接1的那些D    
           接字母的那些D * 字母
         } 相或
       #+end_src
       Y'输出(Y')内容
    7. 根据表达式选择一个写上 L

       
    题 1:
    使用 8 选 1 选择器 74151 实现逻辑函数: ~L = A'B'C + AB'CD + A'BCD' + ABCE~

    [[./img/常用集成器件题2解答.png]]

    #+begin_example
      L = A'B'C + AB'CD + A'BCD' + ABCE
           001    101     011      111
        =  m1  +  m5 * D + m3 * D'  + m7 * E
        =  D1  +  D5 * D + D3 * D'  + D7 * E
    #+end_example

*** 使用 8 选 1 数据选择器实现 ~L = ∑m~ 格式的 3 输入逻辑函数
    1. 下边左一(G): 带圈则接地/输入 0, 若不带圈输入 1
    2. 下边中三(A2A1A0): 一次写入三个输入量(多为 A,B,C)
    3. 将∑m 后的括号展开
    4. 将 m 变成 D
    5. 下边: 
       - 将上步没出现的 D 引出来接 0
       - 前面没乘字母的 D 引出来接 1
    6. 上边: Y 输入的是上一步中接 1 的 D 相或
    7. 根据表达式选择一个写上 L

    题 1: 使用 74151 实现 ~L = F(A,B,C) = ∑m(3, 5, 7)~

    [[./img/常用集成器件题5解答.png]]

    #+begin_example
      L = F(A,B,C) = ∑m(3, 5, 7)
        = m3 + m5 + m7
        = D3 + D5 + D7
    #+end_example

*** 使用 8 选 1 数据选择器实现 ~L = ∑m~ 格式的 3 输入逻辑函数
    1. 下边左一(G): 带圈则接地/输入 0, 若不带圈输入 1
    2. 下边中三(A2A1A0): 一次写入三个输入量(多为 A,B,C)
    3. 将∑m 后的括号展开
    4. 将 m 变成 逻辑函数
    5. 无视函数中 ~ABC~ 以外的输入, 将 ~ABC~ 画成最小项形式
    6. 将 m 变成 D
    7. 下边: 
       - 将上步没出现的 D 引出来接 0
       - 前面没乘字母的 D 引出来接 1
       - 前面乘上字母 N 的 D 引出来接 N
       - ...同上
    8. 上边: Y 输出的是:
       #+begin_src text
         {
           接1的那些D    
           接字母的那些D * 字母
         } 相或
       #+end_src
       Y'输出(Y')内容
    9. 根据表达式选择一个写上 L

    题 1: 使用 74151 实现 ~L = F(A,B,C, D) = ∑m(0, 3, 5, 8, 13, 15)~

    [[./img/常用集成器件题6解答.png]]


    #+begin_example
      L = F(A,B,C, D) = ∑m(0, 3, 5, 8, 13, 15)
        = m0 + m3 + m5 + m8 + m13 + m15
          0000 0001 0101 1000 1101 1111
        = A'B'C'D' + A'B'CD + A'BC'D + AB'C'D' + ABC'D + ABCD
          000        001      010      100       110      111
        = m0 * D' + m1 * D + m2 * D + m4 * D' + m6 * D + m7 * D
        = D(m1 + m2 + m6 + m7) + D'(m0 + m4)
        = D(D1 + D2 + D6 + D7) + D'(D0 + D4)
    #+end_example
** 触发器
*** 给出 D 触发器及输入, 要求画出波形图
    [[./img/触发器题1.png]]
    
    1. 在 CP 凸起左侧或右侧向下画虚线
       1) 若 C1 接口处无"o", 则在左侧
       2) 若 C1 接口处有"o", 则在右侧
    2. 判断每个虚线处输入变量的值是 0 还是 1(若判断不出, 取稍左偏移的值)
    3. 判断每个虚线处输入变量变量的值是有效还是无效, 若可使进入触发器的值为 1, 则
       有效, 反之无效
    4. 根据下标, 得出 Q 的值, 并画在图上
       | 进入触发器的值 | Q 在虚线右侧的值 Q^(n+1) |
       |----------------+--------------------------|
       | 有效           |                        1 |
       | 无效           |                        0 |

    [[./img/触发器题1步骤1.png]]

    [[./img/触发器题1步骤2.png]]
    
    [[./img/触发器题1步骤3.png]]

    [[./img/触发器题1步骤4.png]]

    *Tips*: 
    1. 因为 D 触发器初始状态为 0, 所以 Q 起始值为 0
    2. Q 与 Q'输出值永远想反
    3. D 触发器的特性方程:
       #+begin_example
       Q^(n+1) = D
       #+end_example

*** 给出 JK 触发器及输入, 要求画出波形图
    [[./img/触发器题2.png]]

    1. 在 CP 凸起左侧或右侧向下画虚线
       1) 若 C1 接口处无"o", 则在左侧
       2) 若 C1 接口处有"o", 则在右侧
    2. 判断每个虚线处输入变量的值是 0 还是 1(若判断不出, 取稍左偏移的值)
    3. 判断每个虚线处输入变量变量的值是有效还是无效, 若可使进入触发器的值为 1, 则有效, 反之无效
    4. 根据下表, 得出 Q 的值, 并画在图上
       | J    | K    | Q 在虚线左边的值 Q^n | Q 在虚线右边的值 Q^(n+1) |
       |------+------+----------------------+--------------------------|
       | 有效 | 无效 |                    0 |                        1 |
       |      |      |                    1 |                        1 |
       |------+------+----------------------+--------------------------|
       | 无效 | 有效 |                    0 |                        0 |
       |      |      |                    1 |                        0 |
       |------+------+----------------------+--------------------------|
       | 无效 | 无效 |                    0 |                        0 |
       |      |      |                    1 |                        1 |
       |------+------+----------------------+--------------------------|
       | 有效 | 有效 |                    0 |                        1 |
       |      |      |                    1 |                        0 |

       

    [[./img/触发器题2步骤1.png]]

    
    [[./img/触发器题2步骤2.png]]

    *Tips*:
    1. 结论表简便记忆表:
       | J    | K    | Q^(n+1) |
       |------+------+---------|
       | 有效 | 无效 | 1       |
       | 无效 | 有效 | 0       |
       | 无效 | 无效 | 不变    |
       | 有效 | 有效 | 相反    |
    
    2. 1K 为复位端, 1J 为置位端

    3. 特性方程:
       #+begin_example
       Q^(n+1) = J * (Q^n)' + K' * Q^n
       #+end_example


*** 多个触发器相连    
    [[./img/触发器题3.png]]
    
    
    [[./img/触发器题3步骤1.png]]

    [[./img/触发器题3步骤2.png]]
    
** 计数器集成芯片
   重点:
   74161:
    [[./img/计数器芯片题1步骤1.png]]
   
   组合图:
   [[./img/计数器芯片题11步骤2.png]]
*** 使用 74161 的异步清零功能, 设计 N 进制计数器
    题 1: 使用 74161 的异步清零功能, 设计六进制计数器
    1. 画出 74161
    2. ET, EP 连 1, CP 连凸起
    3. 在 L.D 接口处输入 1
    4. 用 4 位二进制数表示出要求的进制数 N
    5. 找出 N 从左到右哪几位数是 1, 哪几位是 1, 就在 Q3,Q2,Q1,Q0 接口对应的位置上接线,
       接触的线连接一个与非门(多条时)或者非门(一条时), 再连接到 R.D 接口上
    6. 在 Q3,Q2,Q1,Q0 接口顶部写上 Q3,Q2,Q1,Q0


    [[./img/计数器芯片题1步骤1.png]]

    [[./img/计数器芯片题1步骤2.png]]

    ~N = 6 => 0110~
    
    [[./img/计数器芯片题1步骤3.png]]

    题 2: 使用 74161 的异步清零功能, 设计八进制计数器

    [[./img/计数器芯片题2步骤1.png]]

*** 使用 74161 异步清零功能设计 N 进制计数器后, 画出状态图
    题 1: 使用 74161 的异步清零功能, 设计六进制计数器, 并画出状态图
    1. 画出 Q3Q2Q1Q0(用圆圈起来)
    2. 写出 0 到(N-1)的四位二进制数
    3. 用实现, 在每个二进制数上括个圆圈
    4. 用 "->" 从小到大连接所有圆圈, 再从最大指向最小
    5. 在 0 与(N-1) 旁再写上 N 的四位二进制数
    6. 用虚线, 给 N 括上个圆圈
    7. 用 "->", 从(N-1)指向 N, 再由 N 指向 0

       
    ~N = 6~, ~N-1 = 5~
    #+begin_example
      0 => 0000
      1 => 0001
      2 => 0010
      3 => 0011
      4 => 0100
      5 => 0101
    #+end_example

    [[./img/计数器芯片题3步骤1.png]]

    [[./img/计数器芯片题3步骤2.png]]

*** 使用 74161 异步清零功能设计 N 进制计数器后, 检查自启动
    题 1: 使用 74161 的异步清零功能, 设计六进制计数器, 并画出状态图, 检查能否自
    启动
    
    1. 画出状态图
    2. 写出从(N + 1) 到 15 的四位二进制数
    3. 将这些二进制数依次写在状态图上
    4. 用实线圆圈括住这些数字
    5. 找出 N 的二进制数在哪些位上是 1, 若这些数在统一位上也是 1, 则 "->" 指向
       0000, 若不是, 则 "->" 指向下一个数字
    6. 得到结论, 可以自启动
       

    #+begin_example
      N = 6

      7 => 0111
      8 => 1000
      9 => 1001
      10 => 1010
      11 => 1011
      12 => 1100
      13 => 1101
      14 => 1110
      15 => 1111
    #+end_example

    
    [[./img/计数器芯片题4步骤1.png]]

*** 使用 74161 使用同步置数功能设计 N 进制计数器
    题 1: 使用 74161 同步置数功能设计 6 进制计数器

    1. 画出 74161
    2. ET, EP 连 1, CP 连凸起
    3. 在 L.D 接口处输入 1
    4. 从 4 位二进制数 1111 开始一次递减 N 个:
       #+begin_example
         1111, 1110, 1101, 1100...
         |
         |
         N个
       #+end_example

       将第 N 个数的二进制数写在 D3, D2, D1, D0 上
    5. 在 RCO 上连线非门, 再接入 L.D
    6. 在 Q3,Q2,Q1,Q0 接口顶部写上 Q3Q2Q1Q0

       
    #+begin_example
      N = 6

      1111
      1110
      1101
      1100
      1011
      1010
    #+end_example

    [[./img/计数器芯片题5步骤1.png]]

*** 使用 74161 同步置数功能设计 N 进制计数器后, 画出状态图
    题: 使用 74161 同步置数功能设计 6 进制计数器, 并画出状态图

    1. 画出 Q3Q2Q1Q0(用圆圈起来)
    2. 写出 1111, 1110, 1101, 1100...(N 个)四位二进制数
    3. 用实线, 在每个二进制数上括个圆圈
    4. 用 "->" 从小到大连接所有圆圈, 再从最大指向最小

       
    [[./img/计数器芯片题6步骤1.png]]

*** 使用 74161 同步置数功能设计 N 进制计数器后, 检查自启动

    题: 使用 74161 同步置数功能设计 6 进制计数器, 并画出状态图, 检查能否自启动

    1. 画出状态图
    2. 写出 0 到 15-N 的四位二进制数
    3. 将这些二进制数一次写在状态图上
    4. 用实现圆圈括住这些数字
    5. 将这些数字用 "->" 从小到大连接, 最大的数字指向 16-N
    6. 得到结论: 可以自启动

       
    #+begin_example
      N = 6
      15 - N = 9

      0 => 0000
      1 => 0001
      2 => 0010
      3 => 0011
      4 => 0100
      5 => 0101
      6 => 0110
      7 => 0111
      8 => 1000
      9 => 1001

      N = 6
      16 - N = 10

      10 => 010
    #+end_example

    [[./img/计数器芯片题7步骤1.png]]

*** 使用 74160 异步清零功能设计 N 进制计数器, 并画状态图
    题: 使用 74160 的异步清零功能, 设计 6 进制计数器, 并画出状态图

    1. 画出 74160
    2. 将 74160 当初 74141 来做

       
    [[./img/计数器芯片题8步骤1.png]]

*** 使用 74160 同步置数功能设计 N 进制计数器
    题: 使用 74160 同步置数功能设计 6 进制计数器

    1. 画出 74160
    2. ET, EP 连 1, CP 连凸起
    3. 在 *R.D* 接口处输入 1(此处与 74161 不同)
    4. 从 4 位二进制数 *1001* 开始依次递减: (此处与 74161 不同)
       #+begin_example
         1001, 1100, 0111, 0110...
         |
         |
         N个

       #+end_example
       将第 N 个数的二进制数写在 D3, D2, D1, D0 上
    5. 在 RCO 上连线非门, 连接到 *L.D* 上 (此处与 74161 不同)
    6. 在 Q3,Q2,Q1,Q0 接口顶部写上 Q3,Q2,Q1,Q0

       
    #+begin_example
      N = 6

      1001
      1000
      0111
      0110
      0101
      0100
    #+end_example

    [[./img/计数器芯片题9步骤1.png]]

*** 使用 74160 同步置数功能设计 N 进制计数器, 画出状态图
    题: 使用 74160 同步置数功能设计 6 进制计数器, 并画出状态图
    
    1. 画出 Q3Q2Q1Q0(用圆圈起来)
    2. 写出 1001, 1000, 0111, 0110...(N 个) 四位二进制数 (此处与 74161 不同)
    3. 用实线, 在每个二进制数上括个圆圈
    4. 用 "->" 从小到大连接所有圆圈, 再从最大指向最小

       
    #+begin_example
      N = 6

      1001
      1000
      0111
      0110
      0101
      0100
    #+end_example

    
    [[./img/计数器芯片题10步骤1.png]]

*** 使用 74161 和 74151 设计某序列发生器
    题: 试用计数器 74161 和数据选择器 74151 设计一个如下图所示的序列发生器

    1. 根据图像写出循环的八个数
    2. 画出下图
    3. 在 D.0 到 D.7 上一次写出循环的八个数


    [[./img/计数器芯片题11.png]]


    [[./img/计数器芯片题11步骤1.png]]

    10011000

    [[./img/计数器芯片题11步骤2.png]]

    
    [[./img/计数器芯片题11步骤3.png]]

    *注意*: 顺序为 D0 - D7, 画在图中为反向
** 分析时序逻辑电路
*** 判断是同步时序电路还是异步时序电路, 并写出时钟方程
    题: [[./img/分析时序逻辑电路题1.png]]

    观察C1接口是否相同输入, 相同即为同步时序电路, 不同则为异步时序电路

    该题是同步时序电路:
    时钟方程:
    #+begin_example
      CP0 = CP
      CP1 = CP
    #+end_example

*** 写出时序逻辑电路的输出方程
    [[./img/分析时序逻辑电路题1.png]]

    输出方程: Z=...
    等号右边由Q1^n, Q0^n, (Q1^n)', (Q0^n)' 组成

    #+begin_example
      Z = (Q1 ⊕ X) * (Q0^n)'
    #+end_example
    
*** 写出时序逻辑电路的驱动方程
    [[./img/分析时序逻辑电路题1.png]]

    驱动方程即为J,K取值

    #+begin_example
      J0 = X ⊕ (Q1^n)'  K0 = 1
      J1 = Q0 ⊕ X  K1 = 1
    #+end_example

*** 写出时序逻辑点图的次态方程
    [[./img/分析时序逻辑电路题1.png]]

    1. 写出各个触发器的特性方程
       #+begin_example
         JK触发器: Q^(n + 1) = J * (Q^n)' + K' * Q^n
         D触发器: Q^(n + 1) = D
       #+end_example
    2. 将驱动方程中得到的J, K或者D代入

       
    #+begin_example
      Q0^(n + 1) = J0 * (Q^n)' + K0' * Q^n
      Q1^(n + 1) = J1 * (Q^n)' + K1' * Q^n
    #+end_example
    
    #+begin_example
      J0 = X ⊕ (Q1^n)'  K0 = 1
      J1 = Q0 ⊕ X  K1 = 1
    #+end_example
    
    #+begin_example
      Q0^(n + 1) = (X ⊕ (Q1^n)') * (Q0^n)' + 0 * Q0^n
                 = (X ⊕ (Q1^n)') * (Q0^n)'

      Q1^(n + 1) = (X ⊕ (Q0^n)') * (Q1^n)' + 0 * Q1^n
                 = (X ⊕ (Q0^n)') * (Q1^n)'
    #+end_example

*** 作时序逻辑电路的状态转换表
    [[./img/分析时序逻辑电路题1.png]]
    
    1. 将输出方程(Z=?Q^n)与次态方程(Q^(n + 1) = ?)写出来
    2. 分别得出1在未知输入量0时与1时的具体方程
    3. 列出下述表格,分别对应未知输入量为0与1时,在每个表格里, 现态初始为0 0, 次态
       与现态输出由现态代入2中算得, 下一行现态 = 上一行次态, 直到某行次态为 0 0
       为止

       
    | 现态         | 次态                  | 输出 |
    |--------------+-----------------------+------|
    | Q1^n  Q0 ^ n | Q1^(n + 1) Q0^(n + 1) | Z    |
    |--------------+-----------------------+------|
    | ...          | ...                   | ...  |

    #+begin_example
      Z = (Q1 ⊕ X) * (Q0^n)'

      Q0^(n + 1) = (X ⊕ (Q1^n)') * (Q0^n)

      Q1^(n + 1) = (X ⊕ (Q0^n)') * (Q1^n)'
    #+end_example

    由 A ⊕ B = A'B + AB' 可得:
    #+begin_example
      Z = (X * (Q1^n)' + X' * Q1 ^ n) * (Q0^n)'

      Q0^(n + 1) = (X * Q1^n + X' * (Q1^n)') * (Q0^n)'

      Q1^(n + 1) = (X * Q0^n + X' * (Q0^n)') * (Q1^n)'
    #+end_example
    

    当 X = 0 时:
    
    #+begin_example
      Z = (0 * (Q1^n)' + 1 * Q1 ^ n) * (Q0^n)' = Q1^n * (Q0^n)'

      Q0^(n + 1) = (0 * Q1^n + 1 * (Q1^n)') * (Q0^n)' = (Q1^n)' * (Q0^n)'

      Q1^(n + 1) = (0 * Q1^n + 1 * (Q0^n)') * (Q1^n)' = Q0^n * (Q1^n)'
    #+end_example

    | 现态         | 次态                  | 输出 |
    |--------------+-----------------------+------|
    | Q1^n  Q0 ^ n | Q1^(n + 1) Q0^(n + 1) |    Z |
    |--------------+-----------------------+------|
    | 0  0         | 0  1                  |    1 |
    | 0  1         | 1  0                  |    0 |
    | 1  0         | 0  0                  |    1 |

    当 X = 1时:
    
    #+begin_example
      Z = (1 * (Q1^n)' + 0 * Q1 ^ n) * (Q0^n)' = (Q1^n)' * (Q0^n)'

      Q0^(n + 1) = (1 * Q1^n + 0 * (Q1^n)') * (Q0^n)' = Q1^n * (Q0^n)'

      Q1^(n + 1) = (1 * Q1^n + 0 * (Q0^n)') * (Q1^n)' = (Q0^n)' * (Q1^n)'
    #+end_example

    | 现态         | 次态                  | 输出 |
    |--------------+-----------------------+------|
    | Q1^n  Q0 ^ n | Q1^(n + 1) Q0^(n + 1) |    Z |
    |--------------+-----------------------+------|
    | 0  0         | 1  0                  |    1 |
    | 1  0         | 0  1                  |    0 |
    | 0  1         | 0  0                  |    0 |

*** 作时序逻辑电路的状态图
    [[./img/分析时序逻辑电路题1.png]]

    1. 画出 Q1Q0(用圆圈圈起来)
    2. 旁边写上 "未知输入量/Z"
    3. 将现态的数字写出来并用圆圈圈好
    4. 按照未知输入量为0那个表, 在各个圆圈见画 "->", 从表的第一行指向第二行, 第
       二行指向第三行...
    5. 在每个箭头旁边写上 "0/发出箭头行的Z值"
    6. 按照未知输入量为1那个表, 在各个圆圈见画 "->", 从表的第一行指向第二行...
    7. 在每个箭头旁边写上 "1/发出箭头行的Z值"

       
    [[./img/分析时序逻辑电路题1状态图.png]]

    
*** 作时序逻辑电路的时序图
    [[./img/分析时序逻辑电路题1.png]]
    
    1. 根据状态表找出Q的行数, 画 2 * 行数段凸起的CP图
    2. 观察原图C1接口处有无圈
       - 有: 在凸起右侧向下画虚线
       - 无: 在凸起左侧向下画虚线
    3. 在下方画X线, 前半段为0, 后半段1
    4. 根据状态表将Q0与Q1的图画上
    5. 在X转折处向下引虚线, 根据状态表将Z的图画上


    [[./img/分析时序逻辑电路时序图步骤1.png]]
    
    [[./img/分析时序逻辑电路时序图步骤2.png]]
    
*** 分析时序逻辑电路的功能
    题: 时序逻辑电路如下图, 请分析他的功能
    [[./img/分析时序逻辑电路题1.png]]

    [[./img/分析时序逻辑电路的功能步骤1.png]]
    
