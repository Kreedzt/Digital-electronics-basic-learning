
* 数字电路基础
** (绪论)数字量和模拟量
   - 数字量: 在时间上和数量上都是 *离散*, *不连续* 的
     (存在一个最小数量单位Δ)
   - 模拟量: 数字量以外的都模拟量
   - 数字电路和模拟电路:
     工作信号, 研究的对象, 分析/设计方法以及所用的数学工具都有显著的不同

     电子技术: 是研究 *电子器件* 及 *电子器件应用* 的一门学科

     + 电子电路作用: 处理信息 / 能量转换
     + 模拟电路: 用连续的模拟电压/流值来表示信息
     + 数字电路: 用一个离散的电压序列来表示信息

       电路板:
       - 结构: Structure
         + 分级设计
         + 每级有限的复杂度
         + 可复用的模块

       - 接口: Interfaces
         + 系统工程核心元素
         + 隔离技术, 允许升级
         + 主要抽象机构

       - 优秀的系统设计:
         + 最小的代价实现最大的功能
         + 可靠
         + 对未来技术的兼容

*** 计划解决的问题
    - 理解事物工作原理
    - 理解理论基础
    - 学习设计和分析的原则
    - 自己设计电路
** (引言)信息和编码
   了解编码目的, 了解二进制编码

   - 信息: 知识的传递, 描述的一种状态或事实
   - 度量信息: 
     二进制编码事物, 动态位数
   - 目的:
     把现实事物转成二进制数据

*** 编码
    - 意义: 取名

    - 要点:
      + 唯一性
      + 机制
      + 有效位: 编码效率
      + 可靠性
      + 安全性

    - 原则: 依据背景产生的

        
    举例:
    #+begin_quote
    2011010909
    #+end_quote

    数制: 表示数量的规则
    码制: 表示事物的规则

**** 数制
     1. 每一位的构成
     2. 从低位向高位的进位规则

        
     二进制的补码:
     1 位表正负, 其他表示大小

     - 算数运算
       二进制数的 0/1 可以表示数量, 进行四则运算
     - 二进制的正负号也是用 0/1 表示的
       在定点运算中, 最高位为符号位(*0 为正, 1 为负*)
       
       #+begin_example
       +5 = 00101
       -5 = 10101
       #+end_example
       
       #+begin_example
       +5 + (-5) = 00101 + 10101 = ?
       #+end_example

       二进制补码在计算时候, 最高位为符号位, 如果位数为 n, 那么可表达的最大正数为
       2^(N - 1) - 1

       #+begin_example
       11010110 = -42
       #+end_example

       加上小数点:
       #+begin_example
       1101.0110 = -2^3 + 2^2 + 2^0 + 2^-2 + 2^-3 = -2.625
       #+end_example

       补码原则:(为了使负数参与运算)
       + 最高位为符号位(0 为正, 1 为负)

       + 正数的补码和它的原码相同

       + 负数的补码 = 数值位逐位求反 + 1
       
       #+begin_example
       +5 = 0 0101
       -5补码: 1 1011(正数11, 5位总为16)
       #+end_example

       两个补码表示的二进制数相加时的符号位讨论
       结论: 将 2 个加数的符号位和来自最高位数字位的进位相加, 结果就是和的符号

**** 码制
     
     等长编码: 等长编码当中每一个事物都有相应的编码长度

     #+begin_example
     ASCⅡ: 7位二进制
     #+end_example

     *编码的形式可以不唯一*

     常用的十进制代码:
     | 十进制数 | 8421 码 | 余 3 码 | 2421 码 | 5211 码 | 余 3 循环码 |
     |----------+---------+---------+---------+---------+-------------|
     |        0 |    0000 |    0011 |    0000 |    0000 |        0010 |
     |        1 |    0001 |    0100 |    0001 |    0001 |        0110 |
     |        2 |    0010 |    0101 |    0010 |    0100 |        0111 |
     |        3 |    0011 |    0110 |    0011 |    0101 |        0101 |
     |        4 |    0100 |    0111 |    0100 |    0111 |        0100 |
     |        5 |    1000 |    1011 |    1011 |    1000 |        1100 |
     |        6 |    0110 |    1001 |    1100 |    1001 |        1101 |
     |        7 |    0111 |    1010 |    1101 |    1100 |        1111 |
     |        8 |    1000 |    1011 |    1110 |    1101 |        1110 |
     |        9 |    1001 |    1100 |    1111 |    1111 |        1010 |

     出现非 8421 码的原因: 不够 *封闭*, 计算后不在范围内
     
**** 格雷码
     
     *每一位的状态变化都按一定的顺序循环*

     编码顺序依次变化, 按表中顺序变化时, 相邻代码只有一位改变状态

     | 编码顺序 | 二进制 | 格雷码 | 编码顺序 | 二进制码 | 格雷码 |
     |----------+--------+--------+----------+----------+--------|
     |        0 |   0000 |   0000 |        8 |     1000 |   1100 |
     |        1 |   0001 |   0001 |        9 |     1001 |   1101 |
     |        2 |   0010 |   0011 |       10 |     1010 |   1111 |
     |        3 |   0011 |   0010 |       11 |     1011 |   1110 |
     |        4 |   0100 |   0110 |       12 |     1100 |   1010 |
     |        5 |   0101 |   0111 |       13 |     1101 |   1011 |
     |        6 |   0110 |   0101 |       14 |     1110 |   1001 |
     |        7 |    011 |   0100 |       15 |     1111 |   1000 |

     
**** 变长编码
     
     平均编码长度降低

     编码效率提高

**** 哈弗曼编码
     把概率大的事物放在一边, 剩余的相加, 形成二叉树, 循环此步骤

     左边采用 0 分支, 右边 1 分支

     | choice | Pi   | encoding |
     |--------+------+----------|
     | "A"    | 1/3  |       11 |
     | "B"    | 1/2  |        0 |
     | "C"    | 1/12 |      100 |
     | "D"    | 1/12 |      101 |

     - 编码
       #+begin_example
       B C   A  B A  D
       0 100 11 0 11 101
       #+end_example
     
     - 编码树:
       #+begin_example
       |    |
       B(0) 1
            /\
            0 A(1)
            /\
            C(0) D(1)
       #+end_example

       
** 逻辑代数基础
   要点:
   1. 基本逻辑运算
   2. 基本公式, 表示方法
   3. 逻辑函数的化简

*** 逻辑
    事物的因果关系

    #+begin_quote
    1854: 产生: 逻辑不仅仅是哲学问题, 也是数学问题 - George Boole
    Boolean algebra: 所有数值都是二进制值
    #+end_quote

    #+begin_quote
    1906 年: 出现真空电子管
    #+end_quote

*** 逻辑运算
    当二进制代码表示不同逻辑状态时, 可以按一定的规则进行推理运算
    
**** 三种基本运算
     - 与(AND)
       条件同时具备, 结果发生
       ~Y = A *AND* B = A&B = A * B = AB~
       | A | B | Y |
       | 0 | 0 | 0 |
       | 0 | 1 | 0 |
       | 1 | 0 | 0 |
       | 1 | 1 | 1 |

       #+begin_example
       A -- &
            & -- Y
       B -- &
       #+end_example

      #+begin_example
           A -- --
                || -- Y
           B -- --
      #+end_example

     - 或(OR)
       条件之一具备, 结果发生
       ~Y = A *OR* B = A+B~
       | A | B | Y |
       | 0 | 0 | 0 |
       | 0 | 1 | 1 |
       | 1 | 0 | 1 |
       | 1 | 1 | 1 |

       #+begin_example
       A -- 
           >=1 -- Y
       B --
       #+end_example

       #+begin_example
       A --|-\ 
           |  > -- Y
       B --|-/
       #+end_example

     - 非(NOT)
       条件不具备, 结果发生
       ~Y = A' = *NOT* A~
       | A | Y |
       | 0 | 1 |
       | 1 | 0 |

       #+begin_example
           | |
       A --|1|o -- Y
           | |
       #+end_example

       #+begin_example
           |\
       A --| >o -- Y
           |/
       #+end_example

       遇 ~o~ 则反

**** 几种复杂逻辑运算
     - 与非
       ~Y = (A * B)'~
     - 或非
       ~Y = (A + B)'~
     - 与或非
       ~Y = (A * B + C * D)'~
     - 异或
       ~Y = A ⊕ B~

       | A | B | Y |
       | 0 | 0 | 0 |
       | 0 | 1 | 1 |
       | 1 | 0 | 1 |
       | 1 | 1 | 0 |

       相同为 0, 不同为 1
